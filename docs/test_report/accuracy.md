# OpenIM关于消息可达性（可靠性）测试

很多开发者经常询问IM的性能，网上也经常有开发者展示自己的IM系统，号称百万在线，亿级架构。在看到这些数据之前，我更关心的是测试方案和测试过程，以及如何测试消息的可达性？如果一个所谓亿级架构，消息可达性存在问题，那么这个架构的意义何在？

所以，我们在做性能测试之前，先要做消息的可达性（可靠性）的测试，如果不能保证消息收发的正确性，再高的性能也是徒劳。本文重点总结关于OpenIM对于消息可达性测试的方案、过程以及结果。先说结论，在较为正常的网络环境下，OpenIM消息可达率100%，大家可以放心使用在生产环境中。这个也是预料中的结果，由于seq对齐以及同步的机制，保证了OpenIM的消息可达性是业界领先的。

## 消息可达性（可靠性）的定义

IM消息系统的可靠性，通常就是指消息投递的可靠性，即我们经常听到的“消息必达”，通常用消息的不丢失和不重复两个技术指标来表示。确保消息被发送后，能被接收者收到。由于网络环境的复杂性，以及用户在线的不确定性，消息的可靠性（不丢失、不重复）无疑是IM系统的核心指标，也是IM系统实现中的难点之一。总体来说，IM系统的消息“可靠性”，通常就是指聊天消息投递的可靠性（准确的说，这个“消息”是广义的，因为还存用户看不见的各种指令和通知，包括但不限于进群退群通知、好友添加通知等，为了方便描述，统称“消息”）。

从消息发送者和接收者用户行为来讲，消息“可靠性”应该分为以下几种情况：

（1）发送失败，对于这种情况IM系统必须要感知到，明确反馈发送方。如果此消息没有发送成功，发送方可以选择重试或者稍后再试。

（2）发送成功，如果接收方处在“在线”状态，应该立即收到此消息。如果接收方处在“离线”状态不能收到消息，一旦上线则立刻收到消息。

（3）消息不能重复，用数学术语表示：“有且仅有这条消息”，如果重复了，可能表达的意思就变了。 总之，一个商用 IM系统，必须包含消息“可靠性”逻辑，才能谈基本可用，这是IM系统最基本也是最核心的逻辑。

# 模拟场景&测试方案

互联网真实场景复杂，但客户端大体可以分为两种情况：（1）发送消息时，对方在线，能实时收到消息；（2）发送消息时，对方不在线，登录后能收到离线消息；
我们用测试程序模拟互联网客户端各种场景，按照登录、发送消息、接收消息的情况，把测试客户端分为以下几种类型： 
（1）启动测试时立刻登录，发送消息，且接收消息；     

（2）启动测试时立刻登录，不发送消息，只接收消息；   

（3）启动测试时离线，1分钟后登录，发送消息，且接收消息； 

（4）启动测试时离线，2分钟后登录，发送消息，且接收消息； 

（5）启动测试时离线，1分钟后登录，不发送消息，只接收消息 ；

（6）启动测试时离线，2分钟后登录，不发送消息，只接收消息； 

（7）启动测试时在线，接收消息，每次发送消息后，随机sleep一段时间后再发送下一条；

| 登录时间                | 是否发送消息                             | 是否接收消息 | 客户端数量 |
| ----------------------- | ---------------------------------------- | ------------ | ---------- |
| 测试时立刻登录          | 发送消息                                 | 接收消息     | 5个        |
| 测试时立刻登录          | 不发送消息                               | 接收消息     | 5个        |
| 测试时离线，1分钟后登录 | 发送消息                                 | 接收消息     | 5个        |
| 测试时离线，2分钟后登录 | 发送消息                                 | 接收消息     | 5个        |
| 测试时离线，1分钟后登录 | 不发送消息                               | 接收消息     | 5个        |
| 测试时离线，2分钟后登录 | 不发送消息                               | 接收消息     | 5个        |
| 测试时立刻登录          | 随机sleep一段时间后发送消息 （共计10条） | 接收消息     | 5个        |

共计35个客户端，其中15个客户端不发送消息，5个客户端每个发送10条消息，其他客户端发送15万条记录，共计100000X15+10X5= 1500050条记录。
发送模式：每个客户端随机选择其他客户端作为消息接收者；发送一条消息后sleep 20毫秒。
测试预期： 成功发送消息条数和成功接收消息条数相同；

## 服务器配置

服务器2核16G内存10Mb带宽。其中推送rpc 4个，消息入库rpc 4个。mongodb压力较大。

客户端4核8G内存1Mb带宽，部署5台机器，每台机器启动7个压测程序，客户端启动多个[Open-IM-SDK-Core](https://github.com/OpenIMSDK/Open-IM-SDK-Core)，每个core对应一个手机app，由于客户端需要存储本地聊天记录，并落地sqlite，会产生大量的IO操作，所以目前只启动了35个测试客户端。在现实应用场景中，手机app分散在用户手机上，不存在此类问题。

## 测试过程

### 立刻：

（1）登录，发送消息，且接收消息；     5个压测

（2）登录，不发送消息，只接收消息；5个压测

（3）登录，随机sleep一段时间后发送消息 ，且接收消息；5个压测

此时，有10个客户端给35个客户端发送消息，其中15个登录，20个未登录。

### 1分钟后

（1）登录，不发送消息，只接收消息；5个压测

（2）登录，发送消息，且接收消息；5个压测

此时，有15个客户端给35个客户端发送消息，其中25个登录，10个未登录。

### 2分钟后

（1）登录，不发送消息，只接收消息；5个压测

（2）登录，发送消息，且接收消息；5个压测

此时，有25个客户端给35个客户端发送消息，35个客户端全部登录。

## 测试结果

启动35个测试客户端，对于这35个客户端，模拟了现实场景，测试消息的可达性（可靠性）

（1）登录、发送消息、且接收消息；

（2）登录、不发送消息、只接收消息；

（3）离线后再登录、发送消息、且接收消息；

（4）离线后登录、不发送消息、只接收消息；

（5）sleep随机时间发送消息；

每个客户端随机选择其他客户端作为消息接收者，确保收发消息的数据一致。

发送数据1500050条，其中失败60001条，1440049条成功，接收方成功接收1440049条消息（接收方成功接收到消息，写入本地db，并能触发消息回调），其中失败是有发送超时导致，（超时5秒重试3次）

## 测试程序

（1）在test目录下， make install编译测试程序；

（2）修改common.sh  APIADDR  WSADDR  REGISTERADDR  TOKENADDR 替换成服务端的ip地址；

（3）执行./test1.sh启动压测

（4）执行./result.sh启动压测统计

注意事项：

（1）压力不用开太大，因为sdk需要写本地db，客户端会成为压力瓶颈。

（2）因为sdk发送消息时需要调用api获取用户头像和昵称，会成为瓶颈。（在压力测试时可以去掉）

（3）服务端写大量日志会影响性能。

（4）网络带宽可能会影响性能，特别是会导致发送消息失败。

（5）压测客户端日志会影响测试性能。











